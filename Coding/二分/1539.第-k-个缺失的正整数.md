# [1539. 第 k 个缺失的正整数](https://leetcode.cn/problems/kth-missing-positive-number/)

---

## 题目 (简单)

给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。  

请你找到这个数组里第 k 个缺失的正整数。  

示例 1：  

```markdown
输入：arr = [2,3,4,7,11], k = 5
输出：9
解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
```

示例 2：  

```markdown
输入：arr = [1,2,3,4], k = 2
输出：6
解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。
```

提示：  

- 1 <= arr.length <= 1000
- 1 <= arr[i] <= 1000
- 1 <= k <= 1000
- 对于所有 1 <= i < j <= arr.length 的 i 和 j 满足 arr[i] < arr[j] 

进阶：  

你可以设计一个时间复杂度小于 O(n) 的算法解决此问题吗？

---

## 思路

二分

- 实际上二分的是值域，或者说没有缺失时的下标。如果没有缺失nums[mid]-mid-1==0，
- 缺失了一个就等于1，二分查找到>=缺失k个的最小下标，用r来维护，最后while退出时，l==r，指向>=k的最小下标。
- 这个下标的意义是原数组中这个下标对应的元素之前缺了至少k个元素，并且这个下标是所有之前至少缺k个元素中最小的，
- 然后先计算数组中上一个数之前缺了几个值，然后用k减就得到了还缺几个，还缺的加上上一个数就是缺失值。

---

## 代码

```C++
class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        if(arr[0]>k)
            return k; //第一个元素前就缺了k个值，从1开始连续缺，第k个就是k
        int l=0, r=arr.size()-1;
        while(l<=r){
            int mid = (l+r)/2;
            // 没有缺则arr[mid]-mid-1等于0，缺1个等于1
            if(arr[mid]-mid-1 >= k)// 最后r为最后一次满足这个条件的mid再减去1，也就是while退出时的r+1就是满足这个条件的最小mid，
                            // 此时r是不满足的，二分的最后一次while中l==r==mid，此时不满足这个条件，因此l会加1，
                            // 然后l>r退出while，退出时l刚好等于r+1，也就是while退出时l为最小的满足这个条件的下标（mid值）
                r = mid-1;
            else 
                l = mid+1;
        }// while退出时l为最小的满足x-mid-1 >= k的mid，也就是缺失的第k个数一定在arr[l-1]和arr[l]之间
        return k-(arr[l-1] - (l-1)-1)+arr[l-1];// arr[l-1] - (l-1)-1为arr[l-1]之前缺了几个，不够k个的加上arr[l-1]就是第k个
    }
};
```

时间复杂度：**O( logn )**  
空间复杂度：**O( 1 )**

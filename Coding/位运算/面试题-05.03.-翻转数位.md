# [面试题 05.03. 翻转数位](https://leetcode.cn/problems/reverse-bits-lcci/)

---

## 题目 (简单)

给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。  

示例 1：  

```markdown
输入: num = 1775(110111011112)  
输出: 8  
```

示例 2：  

```markdown
输入: num = 7(01112)  
输出: 4  
```

---

## 思路

双指针 + 位运算 + 贪心

---

## 代码

```C++
class Solution{
public:
    // 思路很好，特别是l=r+1
    int reverseBits(int num) {
        int l=0,r=0,Max=0; // 以0为分界点，L是0左边连续1的数量+1（翻转的0），R是0右边连续1的数量，Max记录最大值
        for(int i=0;i<32;i++){
            if((num&1)==1)
                r++;
            else{ // 注意理解这里，遇到0的处理方式
                l = r+1; // 当遇见0时， 0的左边连续1的数量等于上一个0右边连续1的数量加一（当前0本身反转后算一个长度）
                r = 0;
            }
            Max = max(l+r,Max);
            num >>= 1;
        }
        return Max;
    }
};
```

时间复杂度：**O(n)**  
空间复杂度：**O(1)**

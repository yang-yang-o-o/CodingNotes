# [剑指 Offer 14 - II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)

---

## 题目 (中等)

现需要将一根长为正整数 `len` 的绳子剪为若干段，每段长度均为 `正整数`。请返回每段绳子长度的 `最大乘积` 是多少。
答案需要`取模 1e9+7（1000000007）`，如计算初始结果为：1000000008，请返回 1。

示例 1：  
输入：`len` = 12  
输出：81  

提示：  
2 <= `len` <= 1000  
注意：本题与[主站 343 题相同](https://leetcode-cn.com/problems/integer-break/)

---

## 思路

**数学**  

结论：

- 当 n=2 时，最大乘积为 1
- 当 n=3 时，最大乘积为 2
- 当 n=4 时，最大乘积为 4
- 当 n>4 时，得到最大乘积可通过拆分成 2 和 3 来实现，并且 2 的个数小于 3 个，[归纳法证明见](https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/)
由于 `2(x−2) > x` 在 `x > 4` 时恒成立，大于 4，可以一直用 2 拆分，最优的拆分方案不会出现大于 4；
4 可以拆分成 2 和 2，最优的拆分方案也可以不出现 4；
最优的拆分方案只可能包含 1,2,3，但如果出现 1，将 1 加到任意一个数上，最终的乘积都会增大，因此，最优的拆分方案只包含 2 和 3；
如果 2 的个数大于等于 3 个，拆成 2 个 3，乘积大于拆成 3 个 2。

---

## 代码

```C++
class Solution {
public:
    int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        if(n == 4) return 4;
        long res = 1;
        while(n > 4) 
        {
            n -= 3;
            res *= 3;
            res %= 1000000007;
        }
        // 退出while循环时，最后n的值只有可能是：2、3、4。而2、3、4能得到的最大乘积恰恰就是自身值
        // 因为2、3不需要再剪了（剪了反而变小）；4剪成2x2是最大的，2x2恰巧等于4
        return res * n % 1000000007; 
    }
};
```

时间复杂度：**O( 1 )**  
空间复杂度：**O( 1 )**

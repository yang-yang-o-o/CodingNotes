# [172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/description/)

---

## 题目 (中等)

给定一个整数 n ，返回 n! 结果中尾随零的数量。  

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`  

示例 1：  

```markdown
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

示例 2：  

```markdown
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

示例 3：  

```markdown
输入：n = 0
输出：0
```

提示：  

- 0 <= n <= 10^4

进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？

---

## 思路

核心思想就是统计阶乘的连乘式中5的个数，注意5的倍数都可以拆成5和其他的一个整数的乘积。
`最终 5 的个数就是 n/5 + n/25 + n/125 + ...`
25的倍数都可以拆成至少两个5，但是其中的一个已经包含在n/5中了，所以+n/25是加上另一个5。
25的倍数如果可以拆成三个5，那么一定是125的倍数，前两个5已经被n/5,n/25包含了，最后一个5包含在n/125中。以此类推。
或者可以这么理解，将所有5的倍数都拆成1个或者几个5和另外一个数相乘的形式。然后所有5的个数就是要的答案。
`n/5 + n/25 + n/125 + ...` 就是所有的5的个数。

---

## 代码

```C++
//  自己写的解法 
class Solution {
public:
    int trailingZeroes(int n) {
        int res = 0;
        while(n > 0){
            res += n/5;
            n /= 5;
        }
        return res;
    }
};
```

时间复杂度：**O(logn)**  
空间复杂度：**O(1)**

# [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/description/)

---

## 题目 (困难)

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。  

示例 1：  

```markdown
输入：n = 13
输出：6
```

示例 2：  

```markdown
输入：n = 0
输出：0
```

提示：  

- 0 <= n <= 10^9

---

## 思路

`countr += (n / (i * 10)) * i + min(max(n % (i * 10) - i + 1, 0LL), i)`

`(n / (i * 10)) * i` 为去掉余数后小于n的整十、整百、整千... 所包含的1的个数

`n % (i * 10) - i + 1` 为余数部分拥有的1

---

## 代码

```C++
class Solution {
public:
    int countDigitOne(int n)
    {
        int countr = 0;
        for (long long i = 1; i <= n; i *= 10) {// 遍历每一位，个数、十位、百位。。。
            long long divider = i * 10;// 用于取出个位、十位、百位。。。的部分
            // (n / divider) * i ：// 整十、百、千。。。拥有的1
                            //   (n / 10) * 1           有多少个10，就有多少个数是个位为1的
                            //   (n / 100) * 10         有多少个100，就有乘以10的数量个十位为1的数，因为每100，十位为1的就有10个
                            //   (n / 1000) * 100       有多少个1000，就有乘以100的数量个百位为1的数，因为每1000，百位为1的就有100个
                            //   (n / 10000) * 1000     有多少个10000，就有乘以1000的数量个千位为1的数，因为每10000，千位为1的就有1000个
            countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);
            // min(max(n % divider - i + 1, 0LL), i)：// 余数部分拥有的1
                            // n % 10 - 1 + 1 ：        表示
                            // n % 100 - 10 + 1 ：      -10表示从余数中去掉十位为0的10个数，+1表示加上10这个数，和10取最小值是因为100以内十位为1的只有10个数
                            // n % 1000 - 100 + 1 ：    -100表示从余数中去掉百位为0的100个数，+1表示加上100这个数，和100取最小值是因为1000以内百位为1的只有100个数
                            // n % 10000 - 1000+ 1 ：   -1000表示从余数中去掉千位为0的1000个数，+1表示加上1000这个数，和1000取最小值是因为10000以内千位为1的只有1000个数
        }
        return countr;
    }
};
```

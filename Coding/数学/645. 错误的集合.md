# [645. 错误的集合](https://leetcode.cn/problems/set-mismatch/description/)

---

## 题目 (简单)

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。  

给定一个数组 nums 代表了集合 S 发生错误后的结果。  

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。  

示例 1：  

```markdown
输入：nums = [1,2,2,4]
输出：[2,3]
```

示例 2：  

```markdown
输入：nums = [1,1]
输出：[1,2]
```

提示：  

- 2 <= nums.length <= 10^4
- 1 <= nums[i] <= 10^4

---

## 思路

1、排序：排序后，相等的两个数字将会连续出现。此外，检查相邻的两个数字是否只相差1可以找到缺失的数字

2、哈希表：哈希每个该出现的数字，出现了两次的就是重复的，出现了零次的就是缺失的

3、位运算:

- 首先需要知道一个概念，<font color="red"> 一个数和它本身进行异或运算结果为 `0`，`0`和任何数的异或结果为任何数 </font>；对数组中的所有数以及 `1 ~ nums.length` 的数全部进行异或运算，就能得到丢失的数和重复的数的异或结果`（xor）`；然后求 `xor` 的最右比特位，`(1001 0100)` 的最右比特位就是 `(0000 0100)`，使用公式 `int right = xor & (~ (xor - 1))` 即可。
- 因为 `xor` 是丢失的数和重复的数的异或结果，而异或运算是不同位为 `1` 相同位为 `0`，所以 `xor` 的最右为 `1` 的比特位表示，丢失的数和重复的数所有不同位中的最右边一个位。所以根据最右比特位可以将数组中的数和 `1~nums.length` 的数，总的划分为两类，一类这个位为`1`，一类为`0`，重要的一点是因为丢失的数和重复的数在这一位上是不同的，因此丢失的数必然属于`0`类或者`1`类，重复的数必然属于`1`类或者`0`类。将`0`类中的所有数异或，再将`1`类中的所有数异或。因为前面的红色概念，每个类异或最终都会剩下一个数，要么是丢失的数要么是重复的数。因为丢失的数必然不在`nums`里，重复的数必然在`nums`里，因此，检查`0`类剩下的数，如果这个数在`nums`中，那`0`类剩下的就是重复的数，不在`nums`中，剩下的就是丢失的数。

---

## 代码

```C++
// 自己写的解法                             哈希
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int dup,miss;
        for(int i:nums) // 使用正负号来标记，如果i出现了，就把下标i的位置的元素乘以-1，如果乘之前就已经是负的，说明i重复了
            if(nums[abs(i)-1]<0)dup = abs(i);
            else nums[abs(i)-1] *= -1;
        for(int i=0;i<nums.size();i++) // 最后都没有被乘以-1的话，说明其下标+1得到的那个数是缺失的
            if(nums[i]>0)
                miss = i+1;
        return {dup,miss};
    }
};
// 自己写的解法，分组异或
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int xor1=0,xor2=0,xor0=0;
        for(int i:nums)
            xor0 ^= i;
        for(int i=1;i<nums.size()+1;i++)
            xor0 ^= i;  
        int wei = xor0 & ~(xor0-1); // 注意这种获取最后一位1的方式。xor0-1一定会把最后一位1变为0，然后~(xor0-1)就是只有最后一位为1，其余位变为原来的反，最后与上xor0的话，就得到只有最后一位为1，其余位为0
        for(int i:nums)
            if((i&wei) == 0)// 注意这里(i&wei)一定要有括号
                xor1 ^= i;
            else
                xor2 ^= i;
        for(int i=1;i<nums.size()+1;i++)
            if((i&wei) == 0)
                xor1 ^= i;
            else
                xor2 ^= i;
        for(int i:nums)
            if(i==xor2)
                return {xor2,xor1};
        return {xor1,xor2};
    }
};
```

时间复杂度：**O(n)**  
空间复杂度：**O(1)**

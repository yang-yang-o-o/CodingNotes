# [剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/)

---

## 题目 (中等)

你选择掷出 num 个色子，请返回所有点数总和的概率。  

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 num 个骰子所能掷出的点数集合中第 i 小的那个的概率。  

示例 1：  

```markdown
输入：num = 3
输出：[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463]
```

示例 2：  

```markdown
输入：num = 5
输出:[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013]
```

提示：  

- 1 <= num <= 11

---

## 思路

---

## 代码

```C++
// 自己写的解法
class Solution {
public:
    vector<double> dicesProbability(int n) {
        vector<int> dp(67,0);// dp[i]表示和为i的次数
        for(int i=1;i<=6;i++)// 第一个骰子
            dp[i]++;
        for(int i=2;i<=n;i++)// 枚举每个骰子
            for(int j=i*6;j>=i;j--){// 倒序枚举每种状态
                dp[j] = 0;                      // 因为当前骰子不可能掷出0，所以上次的dp[j]不可能用来转移得到这次的dp[j]，所以直接置0，
                for(int cur=1;cur<=6;cur++)// 当前次骰子点数
                    if(j-cur >= i-1)  // 大于等于i-1的含义是掷当前骰子之前的最小点数是i-1，也就是之前的所有骰子都为1，这个条件很重要
                        dp[j] += dp[j-cur];// 完全背包，状态转移
            }
        vector<double> res;
        int all = pow(6,n);// 总的情况数
        for(int i=n;i<=6*n;i++)
            res.push_back(dp[i]*1.0/all);
        return res;
    }
};
```

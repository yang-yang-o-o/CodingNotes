# [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

---

## 题目

给你一个整数数组`nums`，返回数组`answer`，其中`answer[i]`等于`nums`中除`nums[i]`之外其余各元素的乘积。  
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。  
请`不要使用除法`，且在`O(n)`时间复杂度内完成此题。  

示例 1:  
输入: nums = [1,2,3,4]  
输出: [24,12,8,6]  

示例 2:  
输入: nums = [-1,1,0,-3,3]  
输出: [0,0,9,0,0]  

提示：  
2 <= `nums.length` <= 105  
-30 <= `nums[i]` <= 30  
保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内  

进阶：你可以在`O(1)`的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）

---

## 思路

一次遍历，维护当前元素左边的累积  
二次遍历，维护当前元素右边的累积

---

## 代码

```C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        
        int n=nums.size();
        int left=1,right=1;     //left：从左边累乘，right：从右边累乘
        vector<int> res(n,1);
        
        for(int i=0;i<n;++i)    //最终每个元素其左右乘积进行相乘得出结果
        {
            res[i]*=left;       //乘以其左边的乘积
            left*=nums[i];      //更新得到i+1左边的乘积
            
            res[n-1-i]*=right;  //乘以其右边的乘积
            right*=nums[n-1-i]; //更新得到n-1-i-1右边的乘积
        }
        
        return res;
        
    }
};
```

时间复杂度：**O(n)**  
空间复杂度：**O(1)**

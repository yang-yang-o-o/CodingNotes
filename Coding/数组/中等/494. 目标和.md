# [494. 目标和](https://leetcode.cn/problems/target-sum/description/)

---

## 题目

给你一个非负整数数组`nums`和一个整数`target`。  
向数组中的每个整数前添加`'+'`或`'-'`，然后串联起所有整数，可以构造一个`表达式`：  
例如，`nums = [2, 1]`，可以在`2`之前添加`'+'`，在`1`之前添加`'-'`，然后串联起来得到表达式`"+2-1"`。  
返回可以通过上述方法构造的、运算`结果等于target`的不同`表达式`的数目。  

示例 1：  
输入：nums = [1,1,1,1,1], target = 3  
输出：5  
解释：一共有 5 种方法让最终目标和为 3 。  
-1 + 1 + 1 + 1 + 1 = 3  
+1 - 1 + 1 + 1 + 1 = 3  
+1 + 1 - 1 + 1 + 1 = 3  
+1 + 1 + 1 - 1 + 1 = 3  
+1 + 1 + 1 + 1 - 1 = 3  

示例 2：  
输入：nums = [1], target = 1  
输出：1  

提示：  

- 1 <= `nums.length` <= 20
- 0 <= `nums[i]` <= 1000
- 0 <= `sum(nums[i])` <= 1000
- -1000 <= `target` <= 1000

---

## 思路

动态规划（0-1背包）  
0-1背包和完全背包都可以通过二维矩阵来表示dp过程，

- 0-1背包是从第0列开始转移到第n列  
- 完全背包是从第0行开始转移到第n行

---

## 代码

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        vector<int> dp(2001,0); // dp[i] 表示当前考虑范畴内的所有元素可以组合得到i的总组合个数
        // 先把第一个元素加入考虑范畴
        dp[nums[0]+1000] = 1;
        dp[-nums[0]+1000] += 1; // 注意这里要用+=,如果nums[0]为0的话，正负是相等的
        // 再把剩下的元素依次加入考虑范畴
        for(int i =1;i<nums.size();i++){ // 从第二元素开始考虑
            vector<int> next(2001,0);
            for(int j=0;j<=2000;j++){ // 遍历所有状态，更新状态
                if(j-nums[i]>=0 && j-nums[i]<=2000) // 表示nums[i]在表达式中取正，这里这两个边界判定不能漏
                    next[j] += dp[j-nums[i]]; // 注意这里要用+=,如果nums[i]为0的话，正负是相等的
                if(j+nums[i]>=0 && j+nums[i]<=2000) // 表示nums[i]在表达式中取负，这里这两个边界判定不能漏
                    next[j] += dp[j+nums[i]]; // 注意这里要用+=,如果nums[i]为0的话，正负是相等的
            }
            dp = next;
        }
        return dp[S+1000];
    }
};
```

时间复杂度：**O(n*sum)**  
空间复杂度：**O(sum)**

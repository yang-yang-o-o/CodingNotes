# [剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/)

---

## 题目

实现 `pow(x, n)` ，即计算 `x` 的 `n` 次幂函数（即，x^n）。  

示例 1：  
输入：x = 2.00000, n = 10  
输出：1024.00000  
示例 2：  
输入：x = 2.10000, n = 3  
输出：9.26100  
示例 3：  
输入：x = 2.00000, n = -2  
输出：0.25000  
解释：2-2 = 1/22 = 1/4 = 0.25  

提示：  

- -100.0 < x < 100.0
- -2^31 <= n <= 2^31-1
- -10^4 <= x^n <= 10^4

---

## 思路

快速幂 + 迭代：  

每次x = x²，然后n = n/2；就能快速求幂  

x的b次方x^b，b可以用二进制表示，不断地将x = x²，b >>= 1，不断地考虑b的最后一位，此时x也就是对应的一个乘积项  

例如当b为9时，b可以写为 2^3 + 2^0 ，也就对应二进制的 1001，第一位为1，res乘上x就相当于乘上x^(2^0)，然后b右移三次最后一位又为1，此时res乘上的是x^(2^3)，最终res = x^(2^0) * x^(2^3) = x^(2^0 + 2^3) = x^9  

---

## 代码

```C++
class Solution {
public:
    double myPow(double x, int n) {
        if(x==0)return 0;

        long b=n;
        double res=1;
        if(b<0){ // 处理负数次方
            x = 1/x;
            b = -b;
        }

        while(b>0){
            if((b&1)==1) res *= x;// 在b为1的那一位时，将当前的x乘到结果上，比如b为9，也就是1001，
                                // 在第一位时和第4位时将x乘到res上，也就是res = x * x^8 ,中间的两次while没有执行这个if是因为要攒起来得到x^8
            x = x*x;     // 每次x = x²，然后n = n/2；就能快速求幂
            b >>= 1;
        }
        return res;
    }
};
```

时间复杂度：**O( logn )** 即为对 n 进行二进制拆分的时间复杂度。  
空间复杂度：**O( 1 )**
